type BlockInfo @entity {
  id: ID!
  hash: Bytes!
  blockNumber: BigInt!
  timestamp: BigInt!
}

# type Summary @entity {
#   "hardcoded id: SUMMARY"
#   id: ID!
#   "total bidding value (combining all orders) in the system"
#   totalBiddingValue: BigInt!
#   "total orders in the system"
#   totalOrders: BigInt!
#   "total auctions in the system"
#   totalAuctions: BigInt!
# }

type Order @entity {
  id: ID!
  sellAmount: BigInt!
  buyAmount: BigInt!
  "sellAmount / buyAmount"
  price: BigDecimal!
  "sellAmount * 10 ^ -decimalsSellToken"
  volume: BigDecimal!
  timestamp: BigInt!
  auction: AuctionDetail
  user: User!
  "added to easiness on querying user's orders by address"
  userWalletAddress: Bytes!
  status: Status!
  "transaction hash of the order"
  txHash: Bytes!
  "block information of the order transaction"
  blockInfo: BlockInfo!
  "order transactions"
  orderTxns: [OrderTxn!]! @derivedFrom(field: "order")
  "exactOrder gets created when auction is created"
  isExactOrder: Boolean!
  "encoded orderId representing userId,buyAmount,sellAmount"
  encodedOrderId: String!
  lastUpdatedIndex: BigInt!
}

type OrderTxn @entity {
  "txhash+-+logIndex"
  id: ID!
  txHash: Bytes!
  blockInfo: BlockInfo!
  order: Order!
  newStatus: Status!
}

enum Status {
  Placed
  Claimed
  Cancelled
}

type User @entity {
  id: ID!
  address: Bytes!
  createdAuctions: [AuctionDetail!]!
  participatedAuctions: [AuctionDetail!]!
  orders: [Order!]! @derivedFrom(field: "user")
}

type AuctionDetail @entity {
  id: ID!
  auctionId: BigInt!

  exactOrder: Order!
  "order with highest price"
  highestPriceBidOrder: Order
  "order with lowest price"
  lowestPriceBidOrder: Order
  "all orders in the auction(contains placed, claimed, cancelled orders)"
  orders: [Order!]
  "orders which are not cancelled or claimed"
  activeOrders: [Order!]
  "orders which are claimed"
  claimedOrders: [Order!]
  "orders which are cancelled"
  cancelledOrders: [Order!]
  auctioningToken: Token!
  biddingToken: Token!
  auctionEndDate: BigInt!
  orderCancellationEndDate: BigInt!
  startingTimeStamp: BigInt!
  minimumBiddingAmountPerOrder: BigInt!
  minFundingThreshold: BigInt!
  minBuyAmount: BigInt!
  initialSupply: BigInt!
  allowListManager: Bytes!
  allowListSigner: Bytes!
  currentVolume: BigDecimal!
  currentClearingOrderSellAmount: BigInt!
  currentClearingOrderBuyAmount: BigInt!
  currentClearingPrice: BigDecimal!
  "Total sell amount of all orders in the auction"
  currentBiddingAmount: BigInt!
  "Total subjectTokens bid for in the auction by active orders"
  currentSubjectTokenBidAmount: BigInt!
  isAtomicClosureAllowed: Boolean!
  isPrivateAuction: Boolean!
  interestScore: BigDecimal! # need to understand
  uniqueBidders: BigInt!
  "set true when AuctionCleared is emitted"
  isCleared: Boolean!
  "totalOrders which are not cancelled"
  totalOrders: BigInt!
  "number of active bids"
  activeOrderCount: BigInt!

  "transaction hash of the auction creation"
  txHash: Bytes!
  "block information of auction creation"
  blockInfo: BlockInfo!
  clearingPriceOrder: ClearingPriceOrder
  "minimum price in moxie to purchase one subject token"
  minimumPriceInMoxie: BigDecimal!
}

type ClearingPriceOrder @entity {
  id: ID!
  userId: BigDecimal!
  sellAmount: BigDecimal!
  buyAmount: BigDecimal!
}

type Token @entity {
  id: ID! #address
  symbol: String!
  decimals: BigInt!
  auctionsAsAuctioningToken: [AuctionDetail!]! @derivedFrom(field: "auctioningToken")
  auctionsAsBiddingToken: [AuctionDetail!]! @derivedFrom(field: "biddingToken")
}

type OrderCounter @entity {
  id: ID!
  counter: BigInt!
}